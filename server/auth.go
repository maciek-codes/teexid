package main

import (
	"encoding/json"
	"errors"
	"log"
	"net/http"

	"github.com/golang-jwt/jwt/v4"
	"github.com/google/uuid"
)

var SIGNING_KEY = []byte("abc123")

type Token struct {
	PlayerId    string `json:"playerId"`
	TokenString string `json:"token"`
}

func handleAuth(config *Config, w http.ResponseWriter, req *http.Request) {

	w.Header().Add("Access-Control-Allow-Origin", config.frontendHostName)

	// Authenticate a player - generate a UUID and send it back to the user
	// User will have to pass it when opening the websocket
	// We will know the user name and ID and know that it was generated by us
	playerId := uuid.New()

	jwtToken := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
		"playerId": playerId.String(),
	})

	validToken, err := jwtToken.SignedString(SIGNING_KEY)
	if err != nil {
		log.Printf("Token err: %s", err.Error())
		w.WriteHeader(http.StatusInternalServerError)
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(err)
		return
	}

	var token Token
	token.PlayerId = playerId.String()
	token.TokenString = validToken

	w.WriteHeader(http.StatusOK)
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(token)
}

func GetPlayerIdFromToken(tokenString string) (uuid.UUID, error) {
	type Claims struct {
		PlayerId string `json:"playerId"`
		jwt.StandardClaims
	}

	token, err := jwt.ParseWithClaims(tokenString, &Claims{}, func(token *jwt.Token) (interface{}, error) {
		return SIGNING_KEY, nil
	})

	if err != nil {
		return uuid.Nil, err
	}

	if claims, ok := token.Claims.(*Claims); ok {
		playerId, err := uuid.Parse(claims.PlayerId)
		if err != nil {
			return uuid.Nil, err
		}
		return playerId, nil
	} else {
		return uuid.Nil, errors.New("unknow error")
	}
}
