package main

import (
	"encoding/json"
	"flag"
	"log"
	"net/http"
	"strings"
	"time"

	"github.com/google/uuid"
	"github.com/gorilla/mux"
	"github.com/gorilla/websocket"
)

var addr = flag.String("addr", ":8080", "http service address")
var roomMaxDurationMin = flag.Int("room-timeout", 5, "max room duration")
var host = flag.String("host", "localhost", "")
var port = flag.String("port", "8080", "")
var origin = flag.String("allowed-origin", "*", "")

// All the cards available
var cardCount = flag.Int("card-count", 55, "How many cards")
var config *Config

var upgrader = websocket.Upgrader{
	CheckOrigin: func(r *http.Request) bool {
		if config.allowedOrigin == "*" {
			return true
		}
		var origin = r.Header.Get("Origin")
		log.Printf("Origin: %s\n", origin)
		return origin == config.allowedOrigin
	},
} // use mostly default options

// All the rooms in the game
var roomById map[string]*Room = make(map[string]*Room, 0)

func startSocket(config *Config, w http.ResponseWriter, req *http.Request) {
	// To be removed in prod
	w.Header().Add("Access-Control-Allow-Origin", config.allowedOrigin)

	conn, err := upgrader.Upgrade(w, req, nil)

	if err != nil {
		log.Printf("Not a websocket handshake: %s\n", err.Error())
		return
	}

	go receiveMessages(conn)
}

func receiveMessages(conn *websocket.Conn) {
	// Recieve messages from that connection in a coroutine
	for {
		if conn == nil {
			break
		}
		_, payload, err := conn.ReadMessage()
		if err != nil {
			// TODO use ping/pong to detect real disconnect
			log.Printf("Disconnected")
			break
		}

		var command Command
		err = json.Unmarshal(payload, &command)
		if err != nil {
			log.Printf("Unknown message: %s", err.Error())
			continue
		}
		handleCommandFromClient(conn, &command)
	}

	if conn != nil {
		conn.Close()
	}
}

func handleCommandFromClient(conn *websocket.Conn, command *Command) {
	token, err := ParseJwt(command.Token)
	if err != nil {
		log.Println("Invalid token: " + command.Token + ". Error:" + err.Error())
		return
	}

	// Try to find the room and the player
	room, foundRoom := roomById[token.RoomId]
	var player *Player
	if foundRoom {
		player = room.playerMap[token.PlayerId.String()]
	}

	// Make sure the socket is there
	if player != nil {
		playerConn, foundConn := room.conns[player.Id.String()]
		if !foundConn || playerConn.ws != conn {
			room.conns[player.Id.String()] = NewPlayerConn(conn, player, room)
		}
	}

	if command.Type == "ping" {
		// Update user's last ping time
		for _, room := range roomById {
			for _, conn := range room.conns {
				if conn.player.Id == token.PlayerId {
					conn.lastPing = time.Now()
				}
			}
		}
		message := ReponseMessage{Type: "pong"}
		b, _ := json.Marshal(message)
		conn.WriteMessage(websocket.TextMessage, b)
	} else {
		log.Printf("Got command %s from %s with data %s",
			command.Type, token.PlayerId.String(), command.Data)

		if foundRoom {
			player := room.playerMap[token.PlayerId.String()]
			if player != nil {
				room.HandleRoomCommand(player, *command)
				return
			}
		}
		log.Println("Need room to handle " + command.Type)
	}
}

type joinRoomParams struct {
	PlayerName string `json:"playerName"`
	RoomName   string `json:"roomName"`
}

func GetTokenFromHeader(req *http.Request) string {
	// Re-joining with the valid token
	var existingTokenJwt string
	if len(req.Header["X-Room-Token"]) == 1 {
		existingTokenJwt = req.Header["X-Room-Token"][0]
	}
	return existingTokenJwt
}

func handleJoinRoom(config *Config, w http.ResponseWriter, req *http.Request) {
	// CORS
	w.Header().Add("Access-Control-Allow-Origin", config.allowedOrigin)

	decoder := json.NewDecoder(req.Body)
	var params joinRoomParams
	err := decoder.Decode(&params)
	if err != nil {
		log.Printf("Can't decode params", err)
		w.WriteHeader(http.StatusBadRequest)
		return
	}

	// TODO: Potential race condition between checkin room and creating the room
	room, foundRoom := roomById[strings.ToLower(params.RoomName)]

	// If room is playing, can't join
	if foundRoom && room.State != WaitingForPlayers {
		http.Error(w, "game in progress", http.StatusBadRequest)
		return
	}

	// Authenticate a player - generate a UUID and send it back to the user
	// User will have to pass it when opening the websocket
	// We will know the user name and ID and know that it was generated by us
	player := NewPlayer(params.PlayerName, uuid.New())

	if !foundRoom {
		room = createRoom(player.Id, params.RoomName)
	}

	room.AddPlayer(player)

	// Tell other players that there is an update
	room.BroadcastPlayers()

	jwtToken, err := GenerateNewJWT(room.Id, player.Id, player.Name)
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
	}

	// Send room state on join
	res := struct {
		Token             string    `json:"roomToken"`
		RoomId            string    `json:"roomId"`
		OwnerId           string    `json:"ownerId"`
		PlayerId          string    `json:"playerId"`
		PlayerCards       []int     `json:"cards"`
		RoomState         RoomState `json:"roomState"`
		TurnState         TurnState `json:"turnState"`
		Players           []*Player `json:"players"`
		Story             string    `json:"story"`
		CardsSubmitted    []int     `json:"cardsSubmitted"`
		StoryPlayerId     uuid.UUID `json:"storyPlayerId"`
		LastSubmittedCard int       `json:"lastSubmittedCard"`
	}{
		Token: 			   jwtToken,
		RoomId:            room.Id,
		OwnerId:           room.OwnerId.String(),
		PlayerId:          player.Id.String(),
		PlayerCards:       player.Cards,
		RoomState:         room.State,
		TurnState:         room.TurnState,
		Players:           room.Players(),
		Story:             room.Story,
		StoryPlayerId:     room.StoryPlayerId,
		CardsSubmitted:    GetCardsForVoting(room, player),
		LastSubmittedCard: FindLastSubmitted(room, player.Id),
	}
	w.WriteHeader(200)
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(res)
}

func createRoom(playerId uuid.UUID, roomName string) *Room {
	room, foundRoom := roomById[roomName]

	if !foundRoom {
		// cards for the room
		cardIds := make([]int, 0)
		for idx := 0; idx < *cardCount; idx++ {
			cardIds = append(cardIds, idx)
		}

		room = NewRoom(cardIds, playerId, roomName)
		roomById[room.Id] = room
	}
	return room
}

func sendError(conn *websocket.Conn, errorType string, errorMsg string) {
	b, _ := json.Marshal(struct {
		Type string `json:"type"`
		Msg  string `json:"message"`
	}{Type: errorType, Msg: errorMsg})

	errorMessageJson := json.RawMessage(b)

	message := ReponseMessage{
		Type:    "error",
		Payload: &errorMessageJson}

	b, err := json.Marshal(&message)
	if err != nil {
		log.Println("Error marshalling", err)
		return
	}

	log.Printf("Writing %s\n", string(b))

	conn.WriteMessage(websocket.TextMessage, b)
}

func start() {
	r := mux.NewRouter()
	r.HandleFunc("/join_room", func(w http.ResponseWriter, r *http.Request) {
		handleJoinRoom(config, w, r)
	}).Methods("POST")
	r.HandleFunc("/ws", func(w http.ResponseWriter, r *http.Request) {
		startSocket(config, w, r)
	}).Methods("GET")
	r.HandleFunc("/health", func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
		return
	}).Methods("GET", "POST")

	log.Printf("Host %s:%s\n", *host, *port)
	log.Printf("Allowed origin: %s\n", config.allowedOrigin)

	srv := &http.Server{
		Handler: r,
		Addr:    *addr,
		// Good practice: enforce timeouts for servers you create!
		WriteTimeout: 15 * time.Second,
		ReadTimeout:  15 * time.Second,
	}

	roomCleanupTimer := time.NewTimer(2 * time.Second)
	go func() {
		<-roomCleanupTimer.C
		for _, val := range roomById {
			diff := time.Since(val.CreatedAt)
			if int(diff.Minutes()) >= *roomMaxDurationMin {
				delete(roomById, val.Id)
			}
		}
	}()

	log.Printf(("Starting to listen"))
	log.Fatal(srv.ListenAndServe())
}

func main() {
	flag.Parse()
	config = NewConfig(*origin, *cardCount)
	log.Printf("Starting...")
	start()
}
